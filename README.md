# Хеш-таблица

## Аннотация

### Цель работы

Реализовать структуру данных - хеш-таблицу с закрытой адресацией и разрешением конфликтов методом цепочек. После реализации требуется оптимизировать написанную программу тремя разными способами.

### Оборудование

<table>
    <thead>
        <tr>
            <th align="center" colspan = 2>Характеристики экспериментальной установки</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td align="center">ОС</td>
            <td align="center">Ubuntu 24.04.2 LTS <p>
            Linux Kernel 6.11.0-21-generic</td>
        </tr>
        <tr>
            <td align="center">Процессор</td>
            <td align="center">AMD Ryzen 7 7730U with Radeon Graphics
            <p>
            16 ядер
            </td>
        </tr>
        <tr>
            <td align="center">Частота процессора на момент измерений</td>
            <td align="center">2 ГГц
            </td>
        </tr>
    </tbody>
</table>

Фиксирование частоты процессора происходило по средством команд:
``` bash
sudo cpupower frequency-set -u 2010Mhz
sudo cpupower frequency-set -d 1990Mhz
```
После завершения снятия измерений фиксация сбрасывалась командой:
``` bash
sudo cpupower frequency-set -g ondemand
```

## Теоретическая справка

### Структура Хеш-таблицы

Хеш таблица представляет из себя массив бакетов (списков), в которой при добавлении элемента индекс бакета, в который нужно его добавить, определялся по формуле

``Индекс бакета := Хеш элемента % Количество бакетов``

В бакетах же, которыми являются списки, хранятся слова и количество их добавлений.

### Оптимизации

Для анализа программы создавалась хеш-таблица на базе текста всех произведений из серии книг о Гарри Поттере.

Сборка происходила с флагом оптимизации `-O0` с целью упрощения задачи, так как "борьба" с компилятором за оптимизацию слишком сложна при больших значениях флага.

## Ход работы

### Профилирование

Для определения горячих мест в программе был использован профилировщик `valgrind`

Профиль создавался с помощью следующей команды:

``` bash
valgrind --tool=callgrind ./build/hash-table
```

А просмотр профиля происходил с помощью `kcachegrind`, который вызывался следующей командой:

``` bash
kcachegrind Файл_созданный_callgrind
```

### Стартовая версия

#### Описание

Стартовая версия включала в себя составление таблицы из слов в виде строк (`char*`).

#### Результат профилирования

![alt text](data/ProfileBase.png)

### Первая оптимизация

#### Описание

#### Результат профилирования

![alt text](data/ProfileFirstOptimize.png)

### Вторая оптимизация

#### Описание

#### Результат профилирования

![alt text](data/ProfileSecondOptimize.png)

### Третья оптимизация

#### Описание

#### Результат профилирования

![alt text](data/ProfileThirdOptimize.png)

## Выводы
